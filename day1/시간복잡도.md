시간 복잡도 : 문제를 해결하기 위한 연산 횟수로 수행 시간은 1억 번의 연산을 1초의 시간으로 간주
시간 복잡도 유형

- 빅-오메가 : 최선일 때 연산 횟수
- 빅-세타 : 보통일 때 연산 횟수
- 빅-오 : 최악일 때 연산 횟수

```java
/**
0~99 사이의 랜덤 값을 찾는 코드
빅-오메가 : 1번
빅-세타 : N/2번
빅-오 : N번
**/
public class timeComplex {
  public static void main(Sting[] args) {

    int findNum = (int)(Math.random() * 100);
    for(int i = 0; i < 100; i ++) {
      if(i == findNum) {
        System.out.println(i);
        break;
      }
    }
  }
}
```

알고리즘 선택의 기준으로 시간 복잡도 활용하는 법

- 파라미터가 최대 1,000,000 정수개인 정렬 프로그램을 만들 때 버블 정렬(O(n\*\*2))과 병합 정렬(nlongn)의 시간복잡도 중 어떤 것을 사용해야 할까?(시간제한 2초)
  :
  시간제한이 2초 = 2억 번 이하의 연산 횟수로 문제를 해결해야 함.
  연산 횟수 = 알고리즘 시간 복잡도의 n에 데이터의 최대 크기 대입
  - 버블 정렬 : (1,000,000)\*\*2 = 1,000,000,000,000(약 10억) > 2억 -> 부적합
  - 병합 정렬 : 1,000,000log(1,000,000) = 약 2천만 < 2억 -> 적합

시간 복좁도 도출 기준

- 상수는 시간 복잡도 계산에서 제외
  -> n이 1000인 반복문이 한개인 것 과 3개의 중첩되지 않은 반복문의 연산 횟수는 n과 3n으로 3배 차이나지만 시간 복잡도는 O(n)으로 동일함
- 가장 많이 중첩된 반복문의 수행 횟수가 시간 복잡도의 기준
  -> n이 1000인 두 개의 중첩된 반복문의 시간 복잡도는 n\*\*2으로 되고, 해당 코드에서 가장 시간 복잡도가 큰 값이 그 코드의 시간 복잡도가 됨
